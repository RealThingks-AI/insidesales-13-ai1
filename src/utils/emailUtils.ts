/**
 * Email utility functions for consistent email handling across the app
 */

// Avatar color palette for consistent user representation
const AVATAR_COLORS = [
  'bg-blue-500',
  'bg-green-500',
  'bg-purple-500',
  'bg-orange-500',
  'bg-pink-500',
  'bg-teal-500',
  'bg-indigo-500',
  'bg-rose-500',
  'bg-cyan-500',
  'bg-amber-500',
];

/**
 * Generate a consistent avatar color based on email or name
 */
export const getAvatarColor = (identifier: string): string => {
  if (!identifier) return AVATAR_COLORS[0];
  
  let hash = 0;
  for (let i = 0; i < identifier.length; i++) {
    const char = identifier.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  
  return AVATAR_COLORS[Math.abs(hash) % AVATAR_COLORS.length];
};

/**
 * Get initials from a name or email
 */
export const getInitials = (name: string | null, email?: string): string => {
  if (name) {
    const parts = name.trim().split(/\s+/);
    if (parts.length >= 2) {
      return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
    }
    return name.substring(0, 2).toUpperCase();
  }
  
  if (email) {
    const localPart = email.split('@')[0];
    return localPart.substring(0, 2).toUpperCase();
  }
  
  return '??';
};

/**
 * Format email timestamp with relative and absolute options
 */
export const formatEmailTimestamp = (
  timestamp: string,
  options: { relative?: boolean; includeTime?: boolean } = {}
): string => {
  const { relative = false, includeTime = true } = options;
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  
  if (relative) {
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays}d ago`;
  }
  
  // Check if same day
  const isToday = date.toDateString() === now.toDateString();
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  const isYesterday = date.toDateString() === yesterday.toDateString();
  
  const timeStr = date.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true 
  });
  
  if (isToday) {
    return includeTime ? `Today at ${timeStr}` : 'Today';
  }
  
  if (isYesterday) {
    return includeTime ? `Yesterday at ${timeStr}` : 'Yesterday';
  }
  
  const dateStr = date.toLocaleDateString('en-US', { 
    month: 'short', 
    day: 'numeric',
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
  });
  
  return includeTime ? `${dateStr} at ${timeStr}` : dateStr;
};

/**
 * Get user-friendly bounce explanation
 */
export const getBounceExplanation = (bounceType: string | null, bounceReason: string | null) => {
  if (bounceType === 'hard') {
    return {
      title: "Delivery Failed",
      subtitle: "Email address doesn't exist",
      description: "This email could not be delivered because the recipient's email address was not found or is invalid. Please verify the email address and try again with a correct one.",
      severity: 'error' as const,
    };
  }
  if (bounceType === 'soft') {
    return {
      title: "Delivery Delayed",
      subtitle: "Temporary delivery issue",
      description: "This email couldn't be delivered due to a temporary issue (e.g., full mailbox, server busy). The system may retry automatically.",
      severity: 'warning' as const,
    };
  }
  return {
    title: "Delivery Failed",
    subtitle: "Unable to deliver email",
    description: "This email could not be delivered to the recipient.",
    severity: 'error' as const,
  };
};

/**
 * Clean technical bounce reasons for user display
 */
export const cleanBounceReason = (reason: string | null): { summary: string; technical: string | null } => {
  if (!reason) {
    return { summary: '', technical: null };
  }

  // Strip HTML tags
  let cleanedText = reason.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
  
  if (!cleanedText) {
    return { summary: '', technical: null };
  }

  // Extract technical error codes
  const errorCodeMatch = cleanedText.match(/\d{3}\s+\d+\.\d+\.\d+/);
  const hasErrorCode = !!errorCodeMatch;

  // Clean summary
  let summary = cleanedText
    .replace(/^\d{3}\s+\d+\.\d+\.\d+\s*/g, '')
    .replace(/Remote Server returned.*?[-â€“]/i, '')
    .replace(/NDR generated by.*$/i, '')
    .trim();

  const sentences = summary.split(/[.!?]+/).filter(s => s.trim().length > 10);
  if (sentences.length > 0) {
    summary = sentences[0].trim();
    summary = summary.charAt(0).toUpperCase() + summary.slice(1);
    if (!summary.endsWith('.')) {
      summary += '.';
    }
  }

  return { summary, technical: hasErrorCode ? cleanedText : null };
};

/**
 * Strip HTML tags from email content for preview
 */
export const stripHtmlTags = (html: string | null): string => {
  if (!html) return '';
  return html
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n\n')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/\n{3,}/g, '\n\n')
    .trim();
};

/**
 * Extract quoted content separator patterns
 */
export const QUOTED_CONTENT_PATTERNS = [
  /^On .+ wrote:$/m,
  /^From: .+$/m,
  /^-{3,} Original Message -{3,}$/m,
  /^_{3,}$/m,
  /^>{1,}/m,
];

/**
 * Parse email body to separate reply from quoted content
 */
export const parseQuotedContent = (body: string | null): { reply: string; quoted: string | null } => {
  if (!body) return { reply: '', quoted: null };
  
  const cleanBody = stripHtmlTags(body);
  
  for (const pattern of QUOTED_CONTENT_PATTERNS) {
    const match = cleanBody.match(pattern);
    if (match && match.index !== undefined && match.index > 20) {
      return {
        reply: cleanBody.substring(0, match.index).trim(),
        quoted: cleanBody.substring(match.index).trim(),
      };
    }
  }
  
  return { reply: cleanBody, quoted: null };
};

/**
 * Get date group label for email list
 */
export const getDateGroup = (timestamp: string): string => {
  const date = new Date(timestamp);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  const thisWeekStart = new Date(today);
  thisWeekStart.setDate(thisWeekStart.getDate() - thisWeekStart.getDay());
  const lastWeekStart = new Date(thisWeekStart);
  lastWeekStart.setDate(lastWeekStart.getDate() - 7);
  const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
  
  const emailDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  
  if (emailDate >= today) return 'Today';
  if (emailDate >= yesterday) return 'Yesterday';
  if (emailDate >= thisWeekStart) return 'This Week';
  if (emailDate >= lastWeekStart) return 'Last Week';
  if (emailDate >= thisMonthStart) return 'This Month';
  
  return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
};

/**
 * Format sender/recipient display
 */
export const formatEmailAddress = (name: string | null, email: string): string => {
  if (name && name.trim()) {
    return `${name.trim()} (${email})`;
  }
  return email;
};

/**
 * Truncate text with ellipsis
 */
export const truncateText = (text: string, maxLength: number): string => {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + '...';
};
